

                ███  ▒  ▒   ▒  ▒▒▒███
                █    ▒  ▒▒  ▒  ▒    █
                █    ▒  ▒ ▒ ▒  ▒    █
                █    ▒  ▒  ▒▒  ▒    █
                ███  ▒  ▒   ▒  ▒▒▒███

               computing instructions
_______________________________________________________

                 Machine Architecture
_______________________________________________________

Stack		
	CS	computing stack [.. L R]
	RS	return stack 	[.. C]
	BS	block stack		[.. C]

Register	
	R	right (a.k.a top)
	L	left (a.k.a. next)
	B	block (index in PB)
	C	continue (index in PB)
	PC	program counter (index in PB)

Flags
	T	test 
	E	else

Buffer
	PB	program buffer (array of instruction bytes)
	NB	named blocks (letter to index in PB)

_______________________________________________________

                   Instruction Set
_______________________________________________________

Tests
	=	eq		T=L==R, E=f
	!	neq		T=L!=R, E=f
	>	gt		T=L>R,  E=f
	<	lt		T=L<R,  E=f

Arithmetic
	+	add		t=L+R	[.. L R]	[.. t R]
	-	sub		t=L-R	[.. L R]	[.. t R]
	*	mul		t=L*R	[.. L R]	[.. t R]
	/	div		t=L/R	[.. L R]	[.. t R]
	%	mod		t=L%R	[.. L R]	[.. t R]
	_	neg		t=-R	[.. L R]	[.. t R]
	x	dec		t=R--	[.. L R]	[.. t R]
	x	inc		t=R++	[.. L R]	[.. t R]

Bitwise
	&	and		t=L&R	[.. L R]	[.. t R]
	|	or		t=L|R	[.. L R]	[.. t R]
	~	inv		t=~R	[.. L R]	[.. t R]
	^	xor		t=L^R	[.. L R]	[.. t R]
	´	sal		t=L<<R	[.. L R]	[.. t R]
	`	sar		t=L>>R	[.. L R]	[.. t R]

Loads
	0	ldc0	R=0		[.. L R]	[.. L 0]
	1	ldc1	R=1		[.. L R]	[.. L 1]
	2	ldc2	R=2		[.. L R]	[.. L 2]
	3	ldc3	R=3		[.. L R]	[.. L 3]
	4	ldc4	R=4		[.. L R]	[.. L 4]
	5	ldc5	R=5		[.. L R]	[.. L 5]
	6	ldc6	R=6		[.. L R]	[.. L 6]
	7	ldc7	R=7		[.. L R]	[.. L 7]
	8	ldc8	R=8		[.. L R]	[.. L 8]
	9	ldc9	R=9		[.. L R]	[.. L 9]

Stack
	(	dup				[.. L R]	[.. L R R]
	)	drop			[.. L R]	[.. L]
	,	swap			[.. L R]	[.. R L]
	,,					[.. x L R]	[.. R L x]
	,,,					[.. x y L R][.. R y L x]
	:	cut				[.. L R]	[.. R]
	::					[.. x L R]	[.. L R]
	:::					[.. x y L R][.. y L R]

Branching
	{	if		!(T || E) PC="after next }", E=!T, T=f
	}	end		E=f

Blocks
	[	init	B=PC "after ["
	]	exit	PC=C
	.n	stn		NB[n]=B		
	$n	ldn		B=NB[n]
	@	rcur	PC="after previous ["
	x	call	CP++, BS[CP]=B, RS[CP]=PC, PC=b
	a-z		
_______________________________________________________

                       Examples
_______________________________________________________

	abs		0<{_}		ldc0 lt if neg end
	min		>{,}		gt if swap end
	max		<{,}		lt if swap end
	inc		(1+)		dup ldc1 add drop		
	dec		(1-)		dup ldc1 sub drop		
	squr	(*)			dup mul drop

	rot		,,			[.. x L R]	[.. R L x]
	flip	, ,,, ,,	[.. x y L R][.. L R x y]

	fib		[(1>){(1-)(@,(1-)@+)}]
	fib2	[(1>){((1-)@,(2-)@+)}]


_______________________________________________________

              Internal Instruction Set
_______________________________________________________

Internal instructions are those substituted by the VM
to improve program performance at runtime. The ranges
of 128-255 and 0-31 are internal instructions. 

* load constant: instead of identifying the full 
  constant at runtime a "ldc" instruction with 1 or
  more value bytes is substituted. 
  This also takes care of base 10 vs. base 16. 

* 0-10 equal ldc constant 0-10?
